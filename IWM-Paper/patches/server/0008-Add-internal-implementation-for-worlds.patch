From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Philip Kelley <philip@thoriumcube.org>
Date: Sun, 8 Oct 2023 21:15:15 +0100
Subject: [PATCH] Add internal implementation for worlds


diff --git a/src/main/java/com/infernalsuite/iwm/level/InfernalLevel.java b/src/main/java/com/infernalsuite/iwm/level/InfernalLevel.java
new file mode 100644
index 0000000000000000000000000000000000000000..65c00ea7b94b27e8b5e1c2d562e6b394b8428d1d
--- /dev/null
+++ b/src/main/java/com/infernalsuite/iwm/level/InfernalLevel.java
@@ -0,0 +1,91 @@
+package com.infernalsuite.iwm.level;
+
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import com.infernalsuite.iwm.api.world.properties.WorldProperties;
+import com.infernalsuite.iwm.api.world.properties.WorldPropertyMap;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Holder;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.util.datafix.DataFixers;
+import net.minecraft.world.Difficulty;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.biome.Biome;
+import net.minecraft.world.level.chunk.ChunkGenerator;
+import net.minecraft.world.level.dimension.LevelStem;
+import net.minecraft.world.level.storage.LevelStorageSource;
+import net.minecraft.world.level.storage.PrimaryLevelData;
+import net.minecraft.world.level.validation.DirectoryValidator;
+import org.apache.commons.io.FileUtils;
+import org.bukkit.World;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Collections;
+import java.util.UUID;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.locks.ReentrantLock;
+
+public class InfernalLevel extends ServerLevel {
+
+    public static LevelStorageSource CUSTOM_LEVEL_STORAGE;
+
+    static {
+        try {
+            Path path = Files.createTempDirectory("iwm-" + UUID.randomUUID().toString().substring(0, 5)).toAbsolutePath();
+            DirectoryValidator directoryValidator = LevelStorageSource.parseValidator(path.resolve("allowed_symlinks.txt"));
+            CUSTOM_LEVEL_STORAGE = new LevelStorageSource(path, path, directoryValidator, DataFixers.getDataFixer());
+            FileUtils.forceDeleteOnExit(path.toFile());
+        } catch (final IOException e) {
+            throw new IllegalStateException("Couldn't create dummy file directory", e);
+        }
+    }
+
+    private static final ExecutorService WORLD_SAVER_SERVICE = Executors.newFixedThreadPool(4, new ThreadFactoryBuilder()
+            .setNameFormat("IWM Pool Thread #%1$d").build());
+
+    private final ReentrantLock saveLock = new ReentrantLock();
+
+    private boolean ready = false;
+
+    public final NMSInfernalWorld infernalWorld;
+
+    public InfernalLevel(InfernalBootstrap infernalBootstrap, PrimaryLevelData primaryLevelData,
+                         ResourceKey<Level> worldKey, ResourceKey<LevelStem> dimensionKey, LevelStem worldDimension,
+                         World.Environment environment) throws IOException {
+        super(infernalBootstrap, MinecraftServer.getServer(), MinecraftServer.getServer().executor,
+                CUSTOM_LEVEL_STORAGE.createAccess(infernalBootstrap.initial().getName() + UUID.randomUUID(), dimensionKey),
+                primaryLevelData, worldKey, worldDimension, MinecraftServer.getServer().progressListenerFactory.create(11),
+                false, 0, Collections.emptyList(), true, null, environment, null, null);
+
+        this.infernalWorld = new NMSInfernalWorld(infernalBootstrap, this);
+
+        WorldPropertyMap propertyMap = infernalBootstrap.initial().getWorldPropertyMap();
+
+        this.serverLevelData.setDifficulty(Difficulty.valueOf(propertyMap.getValue(WorldProperties.DIFFICULTY).toUpperCase()));
+        this.serverLevelData.setSpawn(new BlockPos(propertyMap.getValue(WorldProperties.SPAWN_X),
+                propertyMap.getValue(WorldProperties.SPAWN_Y),
+                propertyMap.getValue(WorldProperties.SPAWN_Z)),
+                0);
+        super.setSpawnSettings(propertyMap.getValue(WorldProperties.ALLOW_MONSTERS), propertyMap.getValue(WorldProperties.ALLOW_ANIMALS));
+
+        this.pvpMode = propertyMap.getValue(WorldProperties.PVP);
+
+        this.keepSpawnInMemory = false;
+    }
+
+    @Nullable
+    @Override
+    public ChunkGenerator getGenerator(@Nullable InfernalBootstrap bootstrap) {
+        String biomeStr = bootstrap.initial().getWorldPropertyMap().getValue(WorldProperties.DEFAULT_BIOME);
+        ResourceKey<Biome> biomeKey = ResourceKey.create(Registries.BIOME, new ResourceLocation(biomeStr));
+        Holder<Biome> defaultBiome = MinecraftServer.getServer().registryAccess().registryOrThrow(Registries.BIOME).getHolderOrThrow(biomeKey);
+        return new InfernalLevelGenerator(defaultBiome);
+    }
+}
diff --git a/src/main/java/com/infernalsuite/iwm/level/NMSInfernalWorld.java b/src/main/java/com/infernalsuite/iwm/level/NMSInfernalWorld.java
new file mode 100644
index 0000000000000000000000000000000000000000..ddd9930644323aee00b5e7d26658e42f24766a75
--- /dev/null
+++ b/src/main/java/com/infernalsuite/iwm/level/NMSInfernalWorld.java
@@ -0,0 +1,117 @@
+package com.infernalsuite.iwm.level;
+
+import com.infernalsuite.iwm.api.loaders.IWMLoader;
+import com.infernalsuite.iwm.api.world.InfernalChunk;
+import com.infernalsuite.iwm.api.world.InfernalWorld;
+import com.infernalsuite.iwm.api.world.properties.WorldPropertyMap;
+import io.papermc.paper.util.CoordinateUtils;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.world.level.chunk.LevelChunk;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.jglrxavpok.hephaistos.nbt.NBTCompound;
+import org.jglrxavpok.hephaistos.nbt.mutable.MutableNBTCompound;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class NMSInfernalWorld implements InfernalWorld {
+
+    private final InfernalLevel infernalLevel;
+
+    private final MutableNBTCompound extraNbt;
+    private final WorldPropertyMap propertyMap;
+    private final IWMLoader loader;
+    private final String formatName;
+    private final Map<Long, InfernalChunk> chunkStorage;
+    private boolean readOnly;
+
+    // Concurrent access possible due to Async ChunkIO
+    private final Map<Long, CompoundTag> chunkData = new ConcurrentHashMap<>();
+    private final Map<Long, CompoundTag> poiChunkData = new ConcurrentHashMap<>();
+    private final Map<Long, CompoundTag> entityChunkData = new ConcurrentHashMap<>();
+
+    public NMSInfernalWorld(InfernalBootstrap bootstrap, InfernalLevel infernalLevel) {
+        this.infernalLevel = infernalLevel;
+
+        this.extraNbt = bootstrap.initial().getExtraData();
+        this.propertyMap = bootstrap.initial().getWorldPropertyMap();
+        this.loader = bootstrap.initial().getLoader();
+        this.formatName = bootstrap.initial().getFormatName();
+        this.chunkStorage = bootstrap.initial().getChunks();
+        this.readOnly = bootstrap.initial().isReadOnly();
+    }
+
+    @Override
+    public @NonNull String getName() {
+        return this.infernalLevel.serverLevelData.getLevelName();
+    }
+
+    @Override
+    public @NonNull IWMLoader getLoader() {
+        return this.loader;
+    }
+
+    @Override
+    public @NonNull InfernalChunk getChunk(int cx, int cz) {
+        LevelChunk chunk = this.infernalLevel.getChunkIfLoaded(cx, cz);
+        if (chunk == null) return null;
+        return new NMSInfernalChunk(chunk);
+    }
+
+    @Override
+    public Map<Long, InfernalChunk> getChunks() {
+        // TODO
+        return null;
+    }
+
+    @Override
+    public Collection<NBTCompound> getWorldMaps() {
+        return List.of(); // TODO - Should this return something actually useful??
+    }
+
+    @Override
+    public @NonNull WorldPropertyMap getWorldPropertyMap() {
+        return this.propertyMap;
+    }
+
+    @Override
+    public boolean isReadOnly() {
+        return this.loader == null || this.readOnly;
+    }
+
+    @Override
+    public MutableNBTCompound getExtraData() {
+        return this.extraNbt;
+    }
+
+    @Override
+    public @NonNull String getFormatName() {
+        return this.formatName;
+    }
+
+    public void saveChunkData(int chunkX, int chunkZ, CompoundTag data) {
+        this.chunkData.put(CoordinateUtils.getChunkKey(chunkX, chunkZ), data);
+    }
+
+    public CompoundTag readChunkData(int chunkX, int chunkZ) {
+        return this.chunkData.get(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+    }
+
+    public void saveEntityChunkData(int chunkX, int chunkZ, CompoundTag data) {
+        this.entityChunkData.put(CoordinateUtils.getChunkKey(chunkX, chunkZ), data);
+    }
+
+    public CompoundTag readEntityChunkData(int chunkX, int chunkZ) {
+        return this.entityChunkData.get(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+    }
+
+    public void savePoiChunkData(int chunkX, int chunkZ, CompoundTag data) {
+        this.poiChunkData.put(CoordinateUtils.getChunkKey(chunkX, chunkZ), data);
+    }
+
+    public CompoundTag readPoiChunkData(int chunkX, int chunkZ) {
+        return this.poiChunkData.get(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+    }
+}
