From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Philip Kelley <philip@thoriumcube.org>
Date: Thu, 19 Oct 2023 09:05:05 +0100
Subject: [PATCH] Add custom chunk load task for IWM


diff --git a/src/main/java/com/infernalsuite/iwm/level/IWMChunkLoadTask.java b/src/main/java/com/infernalsuite/iwm/level/IWMChunkLoadTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..93bd098e117f1abe1c484fd692ee8bc4a2e0013c
--- /dev/null
+++ b/src/main/java/com/infernalsuite/iwm/level/IWMChunkLoadTask.java
@@ -0,0 +1,418 @@
+package com.infernalsuite.iwm.level;
+
+import ca.spottedleaf.concurrentutil.collection.MultiThreadedQueue;
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
+import ca.spottedleaf.concurrentutil.lock.ReentrantAreaLock;
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import com.infernalsuite.iwm.api.IWMProvider;
+import com.infernalsuite.iwm.api.InfernalWorldManager;
+import com.infernalsuite.iwm.api.formats.FormatRegistry;
+import com.infernalsuite.iwm.api.world.InfernalChunk;
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.chunk.system.io.RegionFileIOThread;
+import io.papermc.paper.chunk.system.poi.PoiChunk;
+import io.papermc.paper.chunk.system.scheduling.*;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.*;
+import org.slf4j.Logger;
+
+import java.lang.invoke.VarHandle;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Consumer;
+
+/**
+ * IWM Adaptation of {@link ChunkLoadTask} to customise chunk loading for IWM hooks
+ * <p>We hook this class in via type-checking in {@link ChunkTaskScheduler#createTask}</p>
+ * @see ChunkLoadTask
+ * @see ChunkProgressionTask
+ */
+public final class IWMChunkLoadTask extends ChunkProgressionTask {
+
+    private static final Logger LOGGER = LogUtils.getClassLogger();
+
+    private final NewChunkHolder chunkHolder;
+    private final ChunkDataLoadTask loadTask;
+
+    private volatile boolean cancelled;
+    private boolean scheduled;
+    private NewChunkHolder.GenericDataLoadTaskCallback entityLoadTask;
+    private NewChunkHolder.GenericDataLoadTaskCallback poiLoadTask;
+    private GenericDataLoadTask.TaskResult<ChunkAccess, Throwable> loadResult;
+    private final AtomicInteger taskCountToComplete = new AtomicInteger(3);
+
+    public IWMChunkLoadTask(final ChunkTaskScheduler scheduler, final InfernalLevel level, final int chunkX, final int chunkZ,
+                            final NewChunkHolder chunkHolder, final PrioritisedExecutor.Priority priority) {
+        super(scheduler, level, chunkX, chunkZ);
+        this.chunkHolder = chunkHolder;
+
+        this.loadTask = new ChunkDataLoadTask(scheduler, level, chunkX, chunkZ, priority);
+        this.loadTask.addCallback((final GenericDataLoadTask.TaskResult<ChunkAccess, Throwable> result) -> {
+            IWMChunkLoadTask.this.loadResult = result;
+            IWMChunkLoadTask.this.tryCompleteLoad();
+        });
+    }
+
+    private void tryCompleteLoad() {
+        if (this.taskCountToComplete.decrementAndGet() == 0) {
+            final GenericDataLoadTask.TaskResult<ChunkAccess, Throwable> result = this.cancelled ? null : this.loadResult;
+            IWMChunkLoadTask.this.complete(result == null ? null : result.left(), result == null ? null : result.right());
+        }
+    }
+
+    @Override
+    public ChunkStatus getTargetStatus() {
+        return ChunkStatus.EMPTY;
+    }
+
+    @Override
+    public boolean isScheduled() {
+        return this.scheduled;
+    }
+
+    @Override
+    public void schedule() {
+        final NewChunkHolder.GenericDataLoadTaskCallback entityLoadTask;
+        final NewChunkHolder.GenericDataLoadTaskCallback poiLoadTask;
+
+        final ReentrantAreaLock.Node schedulingLock = this.scheduler.schedulingLockArea.lock(this.chunkX, this.chunkZ);
+        try {
+            if (this.scheduled) throw new IllegalStateException("schedule() called twice");
+            this.scheduled = true;
+            if (this.cancelled) return;
+
+            if (!this.chunkHolder.isEntityChunkNBTLoaded()) {
+                entityLoadTask = this.chunkHolder.getOrLoadEntityData((GenericDataLoadTask.TaskResult<CompoundTag, Throwable> result) -> tryCompleteLoad());
+            } else {
+                entityLoadTask = null;
+                this.taskCountToComplete.getAndDecrement();
+            }
+
+            if (!this.chunkHolder.isPoiChunkLoaded()) {
+                poiLoadTask = this.chunkHolder.getOrLoadPoiData((GenericDataLoadTask.TaskResult<PoiChunk, Throwable> result) -> tryCompleteLoad());
+            } else {
+                poiLoadTask = null;
+                this.taskCountToComplete.getAndDecrement();
+            }
+
+            this.entityLoadTask = entityLoadTask;
+            this.poiLoadTask = poiLoadTask;
+        } finally {
+            this.scheduler.schedulingLockArea.unlock(schedulingLock);
+        }
+
+        if (entityLoadTask != null) entityLoadTask.schedule();
+        if (poiLoadTask != null) poiLoadTask.schedule();
+
+        this.loadTask.schedule(false);
+    }
+
+    @Override
+    public void cancel() {
+        final boolean scheduled;
+        final ReentrantAreaLock.Node schedulingLock = this.scheduler.schedulingLockArea.lock(this.chunkX, this.chunkZ);
+        try {
+            scheduled = this.scheduled;
+            this.cancelled = true;
+        } finally {
+            this.scheduler.schedulingLockArea.unlock(schedulingLock);
+        }
+
+        if (scheduled) {
+            if (this.entityLoadTask != null) {
+                if (this.entityLoadTask.cancel()) tryCompleteLoad();
+            }
+            if (this.poiLoadTask != null) {
+                if (this.poiLoadTask.cancel()) tryCompleteLoad();
+            }
+        } else {
+            tryCompleteLoad(); // Entity load task
+            tryCompleteLoad(); // Poi load task
+        }
+        this.loadTask.cancel();
+    }
+
+    @Override
+    public PrioritisedExecutor.Priority getPriority() {
+        return this.loadTask.getPriority();
+    }
+
+    @Override
+    public void lowerPriority(PrioritisedExecutor.Priority priority) {
+        final ChunkLoadTask.EntityDataLoadTask entityDataLoadTask = this.chunkHolder.getEntityDataLoadTask();
+        if (entityDataLoadTask != null) entityDataLoadTask.lowerPriority(priority);
+
+        final ChunkLoadTask.PoiDataLoadTask poiDataLoadTask = this.chunkHolder.getPoiDataLoadTask();
+        if (poiDataLoadTask != null) poiDataLoadTask.lowerPriority(priority);
+
+        this.loadTask.lowerPriority(priority);
+    }
+
+    @Override
+    public void setPriority(PrioritisedExecutor.Priority priority) {
+        final ChunkLoadTask.EntityDataLoadTask entityDataLoadTask = this.chunkHolder.getEntityDataLoadTask();
+        if (entityDataLoadTask != null) entityDataLoadTask.setPriority(priority);
+
+        final ChunkLoadTask.PoiDataLoadTask poiDataLoadTask = this.chunkHolder.getPoiDataLoadTask();
+        if (poiDataLoadTask != null) poiDataLoadTask.setPriority(priority);
+
+        this.loadTask.setPriority(priority);
+    }
+
+    @Override
+    public void raisePriority(PrioritisedExecutor.Priority priority) {
+        final ChunkLoadTask.EntityDataLoadTask entityDataLoadTask = this.chunkHolder.getEntityDataLoadTask();
+        if (entityDataLoadTask != null) entityDataLoadTask.raisePriority(priority);
+
+        final ChunkLoadTask.PoiDataLoadTask poiDataLoadTask = this.chunkHolder.getPoiDataLoadTask();
+        if (poiDataLoadTask != null) poiDataLoadTask.raisePriority(priority);
+
+        this.loadTask.raisePriority(priority);
+    }
+
+    protected static abstract class CallbackDataLoadTask<OnMain, FinalCompletion> extends GenericDataLoadTask<OnMain, FinalCompletion> {
+        private TaskResult<FinalCompletion, Throwable> result;
+        private final MultiThreadedQueue<Consumer<TaskResult<FinalCompletion, Throwable>>> waiters = new MultiThreadedQueue<>();
+        protected volatile boolean completed;
+        protected static final VarHandle COMPLETED_HANDLE = ConcurrentUtil.getVarHandle(CallbackDataLoadTask.class, "completed", boolean.class);
+        protected CallbackDataLoadTask(final ChunkTaskScheduler scheduler, final InfernalLevel level, final int chunkX, final int chunkZ,
+                                       final RegionFileIOThread.RegionFileType type, final PrioritisedExecutor.Priority priority) {
+            super(scheduler, level, chunkX, chunkZ, type, priority);
+        }
+
+        public final void addCallback(final Consumer<TaskResult<FinalCompletion, Throwable>> consumer) {
+            if (!this.waiters.add(consumer)) {
+                try {
+                    consumer.accept(this.result);
+                } catch (final Throwable throwable) {
+                    this.scheduler.unrecoverableChunkSystemFailure(this.chunkX, chunkZ, Map.of(
+                            "Consumer", ChunkTaskScheduler.stringIfNull(consumer),
+                            "Completed throwable", ChunkTaskScheduler.stringIfNull(this.result.right())
+                    ), throwable);
+                    if (throwable instanceof ThreadDeath death) {
+                        throw death;
+                    }
+                }
+            }
+        }
+
+        @Override
+        protected final void onComplete(TaskResult<FinalCompletion, Throwable> result) {
+            if ((boolean) COMPLETED_HANDLE.getAndSet((CallbackDataLoadTask<OnMain, FinalCompletion>)this, (boolean) true)) {
+                throw new IllegalStateException("Already completed");
+            }
+            this.result = result;
+            Consumer<TaskResult<FinalCompletion, Throwable>> consumer;
+            while ((consumer = this.waiters.pollOrBlockAdds()) != null) {
+                try {
+                    consumer.accept(result);
+                } catch (final Throwable throwable) {
+                    this.scheduler.unrecoverableChunkSystemFailure(this.chunkX, this.chunkZ, Map.of(
+                            "Consumer", ChunkTaskScheduler.stringIfNull(consumer),
+                            "Completed throwable", ChunkTaskScheduler.stringIfNull(result.right())
+                    ), throwable);
+                    if (throwable instanceof ThreadDeath death) {
+                        throw death;
+                    }
+                    return;
+                }
+            }
+        }
+    }
+
+    public static final class ChunkDataLoadTask extends CallbackDataLoadTask<ChunkAccess, ChunkAccess> {
+
+        private final InfernalLevel level;
+
+        protected ChunkDataLoadTask(final ChunkTaskScheduler scheduler, final InfernalLevel level, final int chunkX, final int chunkZ,
+                                    final PrioritisedExecutor.Priority priority) {
+            super(scheduler, level, chunkX, chunkZ, RegionFileIOThread.RegionFileType.CHUNK_DATA, priority);
+            this.level = level;
+        }
+
+        @Override
+        protected boolean hasOffMain() {
+            return true;
+        }
+
+        @Override
+        protected boolean hasOnMain() {
+            return false;
+        }
+
+        @Override
+        protected PrioritisedExecutor.PrioritisedTask createOffMain(Runnable run, PrioritisedExecutor.Priority priority) {
+            return this.scheduler.loadExecutor.createTask(run, priority);
+        }
+
+        @Override
+        protected PrioritisedExecutor.PrioritisedTask createOnMain(Runnable run, PrioritisedExecutor.Priority priority) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        protected TaskResult<ChunkAccess, Throwable> completeOnMainOffMain(ChunkAccess data, Throwable throwable) {
+            throw new UnsupportedOperationException();
+        }
+
+        private ProtoChunk getEmptyChunk() {
+            return new ProtoChunk(
+                    new ChunkPos(this.chunkX, this.chunkZ), UpgradeData.EMPTY, this.world,
+                    this.world.registryAccess().registryOrThrow(Registries.BIOME), null
+            );
+        }
+
+        @Override
+        protected TaskResult<ChunkAccess, Throwable> runOffMain(CompoundTag data, Throwable throwable) {
+            if (throwable != null) {
+                LOGGER.error("Failed to load chunk data for task {}, chunk data will be lost", this, throwable);
+                return new TaskResult<>(this.getEmptyChunk(), null);
+            }
+
+            if (data == null) {
+                return new TaskResult<>(this.getEmptyChunk(), null);
+            }
+
+            try {
+                InfernalWorldManager iwmApi = IWMProvider.get();
+                FormatRegistry formatRegistry = iwmApi.getFormatRegistry();
+                InfernalChunk infernalChunk = formatRegistry.getFormat(this.level.infernalWorld.getFormatName()).thenApply(optFormat -> optFormat.orElseThrow(() -> {
+                    String errorMessage = "Format '" + this.level.infernalWorld.getFormatName() + "' for world '" + this.world.serverLevelData.getLevelName()
+                            + "' was not present in the FormatRegistry!";
+                    return new IllegalStateException(errorMessage);
+                }).deserializeChunk(this.level.infernalWorld.readChunkData(this.chunkX, this.chunkZ).getByteArray("Serialized"))).join();
+                LevelChunk chunk = InfernalChunkConverter.convertInfernalChunk(this.level, infernalChunk); // TODO - Rewrite as we should use ProtoChunk here
+                return new TaskResult<>(chunk, null);
+            } catch (final ThreadDeath death) {
+                throw death;
+            } catch (final Throwable t) {
+                LOGGER.error("Failed to parse chunk data for task {}, chunk data will be lost", this, t);
+                return new TaskResult<>(this.getEmptyChunk(), null);
+            }
+        }
+
+        @Override
+        protected TaskResult<ChunkAccess, Throwable> runOnMain(ChunkAccess data, Throwable throwable) {
+            throw new UnsupportedOperationException();
+        }
+    }
+
+    public static final class PoiDataLoadTask extends CallbackDataLoadTask<PoiChunk, PoiChunk> {
+        public PoiDataLoadTask(final ChunkTaskScheduler scheduler, final InfernalLevel level, final int chunkX,
+                               final int chunkZ, final PrioritisedExecutor.Priority priority) {
+            super(scheduler, level, chunkX, chunkZ, RegionFileIOThread.RegionFileType.POI_DATA, priority);
+        }
+
+        @Override
+        protected boolean hasOffMain() {
+            return true;
+        }
+
+        @Override
+        protected boolean hasOnMain() {
+            return false;
+        }
+
+        @Override
+        protected PrioritisedExecutor.PrioritisedTask createOnMain(Runnable run, PrioritisedExecutor.Priority priority) {
+            return this.scheduler.loadExecutor.createTask(run, priority);
+        }
+
+        @Override
+        protected PrioritisedExecutor.PrioritisedTask createOffMain(Runnable run, PrioritisedExecutor.Priority priority) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        protected TaskResult<PoiChunk, Throwable> completeOnMainOffMain(PoiChunk data, Throwable throwable) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        protected TaskResult<PoiChunk, Throwable> runOffMain(CompoundTag data, Throwable throwable) {
+            if (throwable != null) {
+                LOGGER.error("Failed to load poi data for task {}, poi data will be lost", this, throwable);
+                return new TaskResult<>(PoiChunk.empty(this.world, this.chunkX, this.chunkZ), null);
+            }
+
+            if (data == null || data.isEmpty()) {
+                return new TaskResult<>(PoiChunk.empty(this.world, this.chunkX, this.chunkZ), null);
+            }
+
+            try {
+                // TODO Parse dat Poi Chunk :D
+            } catch (final ThreadDeath death) {
+                throw death;
+            } catch (final Throwable t) {
+                LOGGER.error("Failed to parse poi data for task {}, poi data will be lost", this, t);
+                return new TaskResult<>(PoiChunk.empty(this.world, this.chunkX, this.chunkZ), null);
+            }
+        }
+
+        @Override
+        protected TaskResult<PoiChunk, Throwable> runOnMain(PoiChunk data, Throwable throwable) {
+            throw new UnsupportedOperationException();
+        }
+    }
+
+    public static final class EntityDataLoadTask extends CallbackDataLoadTask<CompoundTag, CompoundTag> {
+        public EntityDataLoadTask(final ChunkTaskScheduler scheduler, final InfernalLevel level, final int chunkX,
+                                  final int chunkZ, final PrioritisedExecutor.Priority priority) {
+            super(scheduler, level, chunkX, chunkZ, RegionFileIOThread.RegionFileType.ENTITY_DATA, priority);
+        }
+
+        @Override
+        protected boolean hasOffMain() {
+            return true;
+        }
+
+        @Override
+        protected boolean hasOnMain() {
+            return false;
+        }
+
+        @Override
+        protected PrioritisedExecutor.PrioritisedTask createOffMain(Runnable run, PrioritisedExecutor.Priority priority) {
+            return this.scheduler.loadExecutor.createTask(run, priority);
+        }
+
+        @Override
+        protected PrioritisedExecutor.PrioritisedTask createOnMain(Runnable run, PrioritisedExecutor.Priority priority) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        protected TaskResult<CompoundTag, Throwable> completeOnMainOffMain(CompoundTag data, Throwable throwable) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        protected TaskResult<CompoundTag, Throwable> runOffMain(CompoundTag data, Throwable throwable) {
+            if (throwable != null) {
+                LOGGER.error("Failed to load entity date for task {}, entity data will be lost", this, throwable);
+                return new TaskResult<>(null, null);
+            }
+
+            if (data == null || data.isEmpty()) {
+                return new TaskResult<>(null, null);
+            }
+
+            try {
+                // TODO Entity Data Upgrade here... I think?
+            } catch (final ThreadDeath death) {
+                throw death;
+            } catch (final Throwable t) {
+                LOGGER.error("Failed to run converters for entity data for task {}, entity data will be lost", this, t);
+                return new TaskResult<>(null, t);
+            }
+        }
+
+        @Override
+        protected TaskResult<CompoundTag, Throwable> runOnMain(CompoundTag data, Throwable throwable) {
+            throw new UnsupportedOperationException();
+        }
+    }
+
+}
